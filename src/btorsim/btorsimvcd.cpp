#include <cassert>
#include "btorsimvcd.h"

BtorSimVCDWriter::BtorSimVCDWriter (const char* vcd_path, bool readable_vcd, bool yosys_fmt): readable_vcd(readable_vcd), yosys_fmt(yosys_fmt)
{
	current_id = 0;
	current_step = -1;
	vcd_file.open(vcd_path);
}

BtorSimVCDWriter::~BtorSimVCDWriter ()
{
	vcd_file.close();
	for (std::vector<BtorSimState>::size_type i = 0; i < prev_value.size(); i++)
		if (prev_value[i].type != INVALID) prev_value[i].remove();
}

std::string BtorSimVCDWriter::generate_next_identifier()
{
  int rid = current_id++;
  std::string ret;
  do
  {
    char rem = rid % (id_end - id_start);
    ret += (id_start + rem);
    rid = rid / (id_end - id_start);
  }
  while (rid > 0);
  return ret;
}

std::string BtorSimVCDWriter::get_bv_identifier (int64_t id)
{
  if (bv_identifiers.find(id) == bv_identifiers.end())
  {
    if (readable_vcd)
      bv_identifiers[id] = "n" + std::to_string(id);
    else
      bv_identifiers[id] = generate_next_identifier();
  }
  return bv_identifiers[id];
}

std::string BtorSimVCDWriter::get_am_identifier (int64_t id, int64_t idx)
{
  auto key = std::make_pair(id, idx);
  if (am_identifiers.find(key) == am_identifiers.end())
  {
    if (readable_vcd)
      am_identifiers[key] = "n" + std::to_string(id) + "@" + std::to_string(idx);
    else
      am_identifiers[key] = generate_next_identifier();
  }
  return am_identifiers[key];
}

void BtorSimVCDWriter::write_vcd (Btor2Parser *model)
{
  vcd_file << "$version\n\t Generated by btorsim\n$end\n";
  vcd_file << "$timescale 1ns $end\n";
  for (auto i : bv_identifiers)
  {
    Btor2Line *l = btor2parser_get_line_by_id (model, i.first);
    assert(l);
    assert(l->symbol);
    Btor2Sort *sort = get_sort(l, model);
    assert(sort->tag == BTOR2_TAG_SORT_bitvec);
    vcd_file << "$var wire " << sort->bitvec.width << " " << i.second << " " << l->symbol << " $end\n";
  }
  for (auto i : am_identifiers)
  {
    int64_t id = i.first.first;
    int64_t idx = i.first.second;
    Btor2Line *l = btor2parser_get_line_by_id (model, id);
    assert(l);
    assert(l->symbol);
    Btor2Sort *sort = get_sort(l, model);
    assert(sort->tag == BTOR2_TAG_SORT_array);
    Btor2Line *le = btor2parser_get_line_by_id (model, sort->array.element);
    vcd_file << "$var wire " << le->sort.bitvec.width << " " << i.second << " " << l->symbol << "<" << std::hex << idx << std::dec << "> $end\n";
  }
  vcd_file << "$enddefinitions $end\n";

  for (std::string s : value_changes)
    vcd_file << s << "\n";
}

void BtorSimVCDWriter::update_time(int64_t k)
{
	if (current_step < k)
	{
		value_changes.push_back("#" + std::to_string(k*10));
		current_step = k;
	}
}

void BtorSimVCDWriter::add_value_change(int64_t k, int64_t id, BtorSimState state)
{
  switch (state.type)
  {
    case BITVEC:
    {
      if (!state.bv_state)
      {
        msg (1, "No current state for named state %" PRId64 "!", id);
        return;
      }
      if (!prev_value[id].bv_state || btorsim_bv_compare(state.bv_state, prev_value[id].bv_state))
      {
        update_time(k);
        std::string sval("");
        if (state.bv_state->width > 1)
          sval += "b";
        sval += btorsim_bv_to_string(state.bv_state);
        if (state.bv_state->width >1 ) sval += " ";
        value_changes.push_back(sval + get_bv_identifier(id));
        prev_value[id].update(btorsim_bv_copy(state.bv_state));
      }
    }
    break;
    case ARRAY:
    {
      if (!state.array_state)
      {
        msg (1, "No current state for named state %" PRId64 "!", id);
        return;
      }

      if(!prev_value[id].array_state || state.array_state != prev_value[id].array_state)
      {
				update_time(k);
        for (auto it: state.array_state->data)
          if (!prev_value[id].array_state || prev_value[id].array_state->data.find(it.first)==prev_value[id].array_state->data.end() || prev_value[id].array_state->data.at(it.first) != it.second)
          {
            std::string sval("");
            if (it.second->width > 1 ) sval += "b";
            sval += btorsim_bv_to_string(it.second);
            if (it.second->width > 1 ) sval += " ";
            value_changes.push_back(sval + get_am_identifier(id, it.first));
          }
        prev_value[id].update(state.array_state->copy());
      }

    }
    break;
    default:
      die ("Invalid state");

  }
}
